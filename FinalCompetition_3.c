#pragma config(Sensor, S2,     GYRO,           sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     COLOR,          sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     SONAR,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorB,          LEFT,          tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          RIGHT,         tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float k = .5;
int x = NULL, currentDistance, y = NULL, xMax = 4, xMin = 0, yMax = 2, yMin = 0, finalX, newY, newX,OGy,OGx,finalY, maxPower = 25,currentPower = 23, nTurnRatio = 0, orangeLineCount = 0, blueLineCount = 0, blackLineCount = 0;
bool blue, orange, black, cornerFound, turningRight = true, turningLeft, needNewX, needNewY;
float desiredAngle, currentAngle = 0,desiredPower, slewRate = 3, error, range;

void gyroTurning();

void getFinalCoordinates(){
	finalX = 3;
	finalY = 2;
}// END OF getFinalCoordinates()

void lineCounterIncrement(){
	// This sleep is to allow time to passby in order for the boolean flag to only appear once
	sleep(110);
	if(orange == true){
		orangeLineCount ++;
		orange = false;
		if((cornerFound == true) && (x > xMin) && (blackLineCount == 1)){
			x--;
			if(x == 0){
				 blackLineCount --;
			}
		}else if((cornerFound == true) && (x < xMax) && (blackLineCount == 0)){
			x++;
		}
	}else if(blue == true){
		blueLineCount ++;
		blue = false;
		if((cornerFound == true) && (y < yMax) && (blackLineCount == 0)){
			y++;
		}else if((cornerFound == true) && (y > yMin) && (blackLineCount == 1)){
			y--;
		}
	}else if(black == true){
		blackLineCount ++;
		sleep(100);
		if((blackLineCount == 2) && (cornerFound == false)){

			getFinalCoordinates();
			//backUp a little
			currentPower = -25;
			sleep(500);
			nTurnRatio = -100;
			range = 2;
			desiredAngle = PI *(180/PI);
			blackLineCount = 0;
			x = xMax; y = yMin;
			cornerFound = true;
			turningRight = false;
			turningLeft = true;
			gyroTurning();


		}else{

		if((blackLineCount == 0) || (blackLineCount == 1) && (cornerFound == false)){
			nTurnRatio = -50;
			range = 3;
			desiredAngle = -((PI/2)* (180/PI));
		}else if((turningRight == true) && (cornerFound == true)){
			nTurnRatio = -100;
			range = 3;
			desiredAngle = -((PI/2)* (180/PI));
		}else if(((blackLineCount == 0) || (blackLineCount == 1) && (cornerFound == true))
							||((blackLineCount == 2) && (cornerFound == true))){
			nTurnRatio = 50;
			range = 5;
			desiredAngle = -((PI/2)* (180/PI));
			if((blackLineCount == 2) ||((x == xMax) && (y == yMin))){
				 blackLineCount = 0;
			}
			if((x == xMax) && (y == yMin)){
				blackLineCount = 0;
			}
		}
		gyroTurning();
		}
	}
}

void gyroTurning(){
	resetGyro(GYRO);

	if(currentAngle > desiredAngle){
		while(currentAngle > (desiredAngle + range)){
			error = desiredAngle - currentAngle;
			desiredPower = k * error;

			if(currentPower < desiredPower){
				if(currentPower + slewRate < desiredPower)
					currentPower += slewRate;
				else
					currentPower = desiredPower;
				if(currentPower > maxPower)
					currentPower = maxPower;
			}
			else{
				if(currentPower > desiredPower)
					if(currentPower - slewRate > desiredPower)
					currentPower -= slewRate;
				else
					currentPower = desiredPower;
				if(currentPower < -(maxPower))
					currentPower = - maxPower;
			}
			if(turningLeft == true){
				currentAngle = getGyroDegrees(GYRO);
			}else{
				currentAngle = -getGyroDegrees(GYRO);
			}
		}// END OF while(currentAngle > desiredAngle)
	}else if(currentAngle < desiredAngle){
		while(currentAngle < (desiredAngle - range)){
			error = desiredAngle - currentAngle;
			desiredPower = k * error;

			if(currentPower < desiredPower){
				if(currentPower + slewRate < desiredPower)
					currentPower += slewRate;
				else
					currentPower = desiredPower;
				if(currentPower > maxPower)
					currentPower = maxPower;
			}
			else{
				if(currentPower > desiredPower)
					if(currentPower - slewRate > desiredPower)
					currentPower -= slewRate;
				else
					currentPower = desiredPower;
				if(currentPower < -(maxPower))
					currentPower = - maxPower;
			}
			currentAngle = -getGyroDegrees(GYRO);
		}// END OF while(currentAngle < desiredAngle)
	}
	currentAngle = 0;

	if(black == true){
		nTurnRatio = 0;
		currentPower = 23;
		black = false;
		resetGyro(GYRO);
	}
}

task gridLocationUpdate(){

	while(cornerFound == true){
			if((blue == true)||(orange == true))
				 lineCounterIncrement();
		}// END OF WHILE LOOP
}

task gridCoordinates(){
	while(true){
		displayBigTextLine(0,"xLocal: %i",x);
		displayBigTextLine(2,"yLocal: %i",y);
	}
}

task readColor(){
	while(true){
		if(getColorName(COLOR) == colorBlack){
			black = true;
			currentPower = 0;
		}
		else if((getColorName(COLOR) == colorBlue)){
			blue = true;
		}
		else if((getColorName(COLOR)!= colorWhite)&&(getColorName(COLOR)!= colorBlack)&&(getColorName(COLOR)!= colorBlue)){
			orange = true;
		}
		else if((getColorName(COLOR) == colorWhite)){
		}
		lineCounterIncrement();
	}// END OF WHILE LOOP
}// END OF readColorTask()


task controllerTask(){
	while(true){
		if(cornerFound == true){
			sleep(1000);
			while(y != finalY){
				 	// the robot is traveling north when blackLineCount == 0
			 	blackLineCount = 0;
			 	if(currentDistance < 15){
			 			needNewY = true;
			 			switch(y){
			 				//case (1) means that this obstacle is at grid(4,2)
			 				case(0):
			 					OGy = finalY;
			 					newY = y;
			 					finalY = newY;
			 					if(x == finalX){
			 						needNewX = true;
			 					}
			 					break;
			 				case(1):
			 					OGy = finalY;
			 					newY = y;
			 					finalY = newY;
			 					break;
			 		}
			 	}
			}
			if(y == finalY){
			   if(needNewY == true){
			      currentPower = 0;
			      black = true;
			  	}else{
			  			if(needNewX == true){
					 			turningRight = true;
					 			turningLeft = false;
					 			finalX = OGx;
					 			needNewX = false;
					 		}else{
			   			sleep(2000);
				 			black = true;
				 		}
					}
			}

			if(needNewX == true){
				 OGx = finalX;
				 newX = (x - 1);
				 finalX = newX;
			}

			while(x != finalX){
				 if(x < finalX){
				   // going East in the X direction
				   blackLineCount = 0;
				 }else{
				  // going West in the X direction
					blackLineCount = 1;
				 }
			}
			if(x == finalX){
				 sleep(2000);
				 black = false;
				 if(needNewY == true){
				   black = true;
					 turningRight = true;
					 turningLeft = false;
					 finalY = OGy;
					 needNewY = false;
				}else{
				 stopAllTasks();
				}
			}
		}
	}
}// END OF controllerTask()


task readDistance(){
	while(true)
	{
		currentDistance = getUSDistance(SONAR);
		displayBigTextLine(4, "CD: %.2f cm", currentDistance);
		sleep(10);
	}
}

task main(){
	resetGyro(GYRO);
	sensorReset(SONAR);
	startTask(readDistance);
	startTask(gridCoordinates);
	startTask(readColor);
	startTask(gridLocationUpdate);
	startTask(controllerTask);
	while(true){
		setMotorSync(RIGHT,LEFT,nTurnRatio,currentPower);
	}
}
